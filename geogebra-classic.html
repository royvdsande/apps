<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GeoCanvas Classic</title>
  <style>
    :root {
      color-scheme: light;
      --toolbar-height: 56px;
      --sidebar-width: min(320px, 32vw);
      --accent: #3367d6;
      --border: #d9d9d9;
      --bg: #f8f8fb;
      --panel-bg: #ffffff;
      font-family: "Inter", "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: var(--bg);
      color: #222;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      height: var(--toolbar-height);
      background: var(--panel-bg);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 12px;
      flex-wrap: wrap;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      letter-spacing: 0.01em;
      color: #3a3a3a;
    }

    .brand svg {
      width: 28px;
      height: 28px;
      color: var(--accent);
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      min-width: 240px;
    }

    .tool-button {
      background: transparent;
      border: 1px solid transparent;
      border-radius: 12px;
      padding: 6px 8px;
      min-width: 44px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s ease, border 0.15s ease, color 0.15s ease;
      color: #404040;
      cursor: pointer;
    }

    .tool-button svg {
      width: 22px;
      height: 22px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.8;
      vector-effect: non-scaling-stroke;
    }

    .tool-button.active {
      background: rgba(51, 103, 214, 0.12);
      border-color: rgba(51, 103, 214, 0.6);
      color: var(--accent);
    }

    .tool-button:hover {
      background: rgba(0,0,0,0.05);
    }

    .layout {
      flex: 1;
      display: flex;
      min-height: 0;
    }

    .sidebar {
      flex: 0 0 var(--sidebar-width);
      max-width: 400px;
      background: var(--panel-bg);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: transform 0.25s ease;
      z-index: 2;
    }

    .sidebar.hidden {
      transform: translateX(calc(-1 * var(--sidebar-width)));
    }

    .sidebar.collapsed-desktop {
      display: none;
    }

    .sidebar-header {
      padding: 14px 16px 10px;
      font-weight: 600;
      font-size: 0.95rem;
      color: #555;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .algebra-list {
      flex: 1;
      overflow: auto;
      padding: 0 12px 12px;
    }

    .algebra-item {
      background: rgba(0,0,0,0.03);
      border-radius: 12px;
      padding: 10px 12px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .algebra-color {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      flex: 0 0 auto;
    }

    .algebra-label {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      font-size: 0.92rem;
    }

    .algebra-label strong {
      font-weight: 600;
      color: #222;
    }

    .algebra-detail {
      color: #555;
    }

    .delete-button {
      flex: 0 0 auto;
      border: 1px solid transparent;
      background: transparent;
      border-radius: 10px;
      width: 32px;
      height: 32px;
      display: grid;
      place-items: center;
      cursor: pointer;
      color: #8a8a8a;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .delete-button svg {
      width: 18px;
      height: 18px;
      stroke-width: 1.8;
      stroke: currentColor;
      fill: none;
    }

    .delete-button:hover {
      background: rgba(0,0,0,0.08);
      color: #444;
    }

    .graph-container {
      flex: 1;
      position: relative;
      background: var(--panel-bg);
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
      flex: 1;
      touch-action: none;
      background: #fff;
      display: block;
    }

    .axis-label {
      position: absolute;
      font-size: 0.75rem;
      color: #666;
      pointer-events: none;
    }

    .command-bar {
      border-top: 1px solid var(--border);
      background: var(--panel-bg);
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .command-bar > span {
      font-size: 1.25rem;
      color: #777;
    }

    .command-input {
      flex: 1;
      min-width: 220px;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 14px;
      font-size: 0.95rem;
      background: #fff;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    .command-input:focus {
      outline: none;
      border-color: rgba(51, 103, 214, 0.6);
      box-shadow: 0 0 0 4px rgba(51, 103, 214, 0.15);
    }

    .command-button {
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 12px;
      width: 44px;
      height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #444;
      cursor: pointer;
      transition: border 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    }

    .command-button svg {
      width: 22px;
      height: 22px;
      stroke-width: 1.8;
      stroke: currentColor;
      fill: none;
    }

    .command-button.active {
      border-color: rgba(51, 103, 214, 0.6);
      box-shadow: 0 0 0 3px rgba(51, 103, 214, 0.15);
      color: var(--accent);
    }

    .badge {
      background: rgba(51,103,214,0.1);
      color: var(--accent);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .math-keyboard {
      background: #f4f4fb;
      border-top: 1px solid var(--border);
      padding: 12px;
      display: none;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 -12px 40px rgba(0,0,0,0.08);
    }

    .math-keyboard.active {
      display: flex;
    }

    .quick-actions {
      display: none;
      margin-top: 8px;
      gap: 8px;
    }

    .keyboard-tabs {
      display: flex;
      gap: 8px;
    }

    .keyboard-tab {
      flex: 0 0 auto;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.92);
      color: #555;
      padding: 8px 14px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease;
    }

    .keyboard-tab.active {
      color: var(--accent);
      border-color: rgba(51,103,214,0.6);
      background: rgba(51,103,214,0.08);
    }

    .keyboard-rows {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .keyboard-row {
      display: flex;
      gap: 8px;
      flex-wrap: nowrap;
    }

    .keyboard-key {
      flex: 1;
      border: 1px solid rgba(67, 79, 110, 0.18);
      background: rgba(255,255,255,0.96);
      border-radius: 12px;
      min-height: 44px;
      font-size: 1rem;
      font-weight: 600;
      color: #2d2d2d;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      user-select: none;
    }

    .keyboard-key.small {
      flex: 0 0 54px;
    }

    .keyboard-key.wide {
      flex: 0 0 96px;
    }

    .keyboard-key:hover {
      background: rgba(51,103,214,0.08);
    }

    .keyboard-key:active {
      transform: scale(0.97);
      box-shadow: inset 0 0 0 2px rgba(51,103,214,0.2);
    }

    .floating-controls {
      position: absolute;
      right: 12px;
      top: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1;
    }

    .round-button {
      width: 42px;
      height: 42px;
      border-radius: 21px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.94);
      box-shadow: 0 8px 24px rgba(0,0,0,0.08);
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .round-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.12);
    }

    .round-button svg {
      width: 20px;
      height: 20px;
      stroke: #444;
      fill: none;
      stroke-width: 2;
    }

    @media (max-width: 920px) {
      :root {
        --sidebar-width: min(280px, 70vw);
      }

      body.sidebar-open::after {
        content: "";
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.28);
        pointer-events: none;
        z-index: 4;
      }

      .layout {
        position: relative;
      }

      .sidebar {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        box-shadow: 12px 0 40px rgba(0,0,0,0.22);
        max-width: min(360px, 78vw);
        transform: translateX(-105%);
        z-index: 5;
      }

      body.sidebar-open .sidebar {
        transform: translateX(0);
      }

      .graph-container {
        flex: 1;
      }

      .sidebar.collapsed-desktop {
        display: flex;
      }

      .math-keyboard {
        box-shadow: 0 -8px 28px rgba(0,0,0,0.12);
      }

      .command-bar {
        position: sticky;
        bottom: 0;
        background: rgba(255,255,255,0.96);
        backdrop-filter: blur(12px);
        box-shadow: 0 -12px 24px rgba(0,0,0,0.12);
        z-index: 3;
      }

      .quick-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 10px 12px;
        background: rgba(255,255,255,0.95);
        border-top: 1px solid var(--border);
      }
    }

    @media (max-width: 600px) {
      header {
        gap: 8px;
        padding: 6px 10px;
        height: auto;
      }

      .brand {
        flex: 1;
      }

      .toolbar {
        order: 3;
        width: 100%;
        justify-content: flex-start;
      }

      .tool-button {
        min-width: 40px;
        min-height: 40px;
        border-radius: 10px;
      }

      .command-bar {
        padding: 10px;
      }
    }

    .quick-action {
      border: 1px solid rgba(51,103,214,0.2);
      background: rgba(51,103,214,0.08);
      color: var(--accent);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease, transform 0.2s ease;
    }

    .quick-action:hover {
      background: rgba(51,103,214,0.16);
    }

    .quick-action:active {
      transform: scale(0.97);
    }
  </style>
</head>
<body>
  <header>
    <button class="tool-button" id="toggle-sidebar" aria-label="Wissel algebra-paneel">
      <svg viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 4h16" />
        <path d="M4 12h10" />
        <path d="M4 20h16" />
      </svg>
    </button>
    <div class="brand">
      <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="16" cy="16" r="10" opacity="0.3" />
        <path d="M16 6v4" />
        <path d="M16 22v4" />
        <path d="M6 16h4" />
        <path d="M22 16h4" />
        <circle cx="16" cy="16" r="4" />
      </svg>
      GeoCanvas Classic
    </div>
    <div class="toolbar" role="toolbar" aria-label="Tekengereedschap">
      <button class="tool-button active" data-tool="move" aria-label="Verplaats gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 3v18" />
          <path d="M3 12h18" />
          <path d="M8 7l4-4 4 4" />
          <path d="M8 17l4 4 4-4" />
          <path d="M7 8l-4 4 4 4" />
          <path d="M17 8l4 4-4 4" />
        </svg>
      </button>
      <button class="tool-button" data-tool="point" aria-label="Punt gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="4" />
        </svg>
      </button>
      <button class="tool-button" data-tool="segment" aria-label="Lijnstuk gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M6 18 18 6" />
          <circle cx="6" cy="18" r="2.5" />
          <circle cx="18" cy="6" r="2.5" />
        </svg>
      </button>
      <button class="tool-button" data-tool="line" aria-label="Rechte lijn gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 20 20 4" />
        </svg>
      </button>
      <button class="tool-button" data-tool="circle" aria-label="Cirkel gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="7" />
          <circle cx="12" cy="12" r="2.2" />
        </svg>
      </button>
      <button class="tool-button" data-tool="polygon" aria-label="Veelhoek gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M6 4 3 9l3 5 6 6 6-3 3-5-3-5-6-3z" />
        </svg>
      </button>
      <button class="tool-button" data-tool="text" aria-label="Tekst gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 5h16" />
          <path d="M9 5v14" />
          <path d="M15 19V5" />
        </svg>
      </button>
      <span class="badge">Beta</span>
    </div>
  </header>
  <main class="layout">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        Algebra
        <button class="tool-button" id="close-sidebar" aria-label="Sluit paneel">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <path d="m7 7 10 10" />
            <path d="m17 7-10 10" />
          </svg>
        </button>
      </div>
      <div class="algebra-list" id="algebra-list" aria-live="polite"></div>
    </aside>
    <section class="graph-container">
      <div class="floating-controls">
        <div class="round-button" id="zoom-in" aria-label="Zoom in">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="7" />
            <path d="M11 8v6" />
            <path d="M8 11h6" />
            <path d="m20 20-3-3" />
          </svg>
        </div>
        <div class="round-button" id="zoom-out" aria-label="Zoom uit">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="7" />
            <path d="M8 11h6" />
            <path d="m20 20-3-3" />
          </svg>
        </div>
        <div class="round-button" id="reset-view" aria-label="Reset weergave">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 1 0 3.1-6.9L3 8" />
            <path d="M3 3v5h5" />
          </svg>
        </div>
      </div>
      <canvas id="board" width="1600" height="1200" aria-label="Coördinaatvlak"></canvas>
      <div class="quick-actions" id="quick-actions" role="group" aria-label="Snelle functievoorbeelden"></div>
      <div class="command-bar">
        <span aria-hidden="true">+</span>
        <input type="text" id="command-input" class="command-input" placeholder="Voer een opdracht of functie in, bijv. y=x^2 of A=(2,1)" autocomplete="off" />
        <button class="command-button" id="toggle-keyboard" type="button" aria-label="Toon toetsenbord" aria-pressed="false">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="5" width="18" height="14" rx="2" ry="2" />
            <path d="M7 9h0" />
            <path d="M11 9h0" />
            <path d="M15 9h0" />
            <path d="M7 13h0" />
            <path d="M11 13h0" />
            <path d="M15 13h0" />
          </svg>
        </button>
      </div>
      <div class="math-keyboard" id="math-keyboard" aria-hidden="true">
        <div class="keyboard-tabs" role="tablist" aria-label="Toetsenbord categorieën"></div>
        <div class="keyboard-rows" role="group" aria-live="polite"></div>
      </div>
    </section>
  </main>
  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const graphContainer = document.querySelector('.graph-container');
    const commandBar = document.querySelector('.command-bar');
    const sidebar = document.getElementById('sidebar');
    const toggleSidebarBtn = document.getElementById('toggle-sidebar');
    const closeSidebarBtn = document.getElementById('close-sidebar');
    const algebraList = document.getElementById('algebra-list');
    const commandInput = document.getElementById('command-input');
    const keyboardToggle = document.getElementById('toggle-keyboard');
    const keyboard = document.getElementById('math-keyboard');
    const keyboardTabs = keyboard.querySelector('.keyboard-tabs');
    const keyboardRows = keyboard.querySelector('.keyboard-rows');
    const quickActions = document.getElementById('quick-actions');

    const DPR = window.devicePixelRatio || 1;

    const state = {
      tool: 'move',
      scale: 80,
      origin: { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 },
      points: [],
      segments: [],
      lines: [],
      circles: [],
      polygons: [],
      texts: [],
      functions: [],
      functionColorIndex: 0,
      functionCounter: 0,
      draggingPoint: null,
      dragOffset: { x: 0, y: 0 },
      panning: false,
      panStart: { x: 0, y: 0 },
      tempPoints: [],
      pinch: null,
    };

    const COLORS = {
      point: '#1f6feb',
      line: '#2b4aa0',
      segment: '#2b4aa0',
      circle: '#c03fb5',
      polygon: '#009688',
      text: '#444',
      function: '#e36209'
    };

    const FUNCTION_COLORS = ['#d83b01', '#1f6feb', '#2da44e', '#8b3dd9', '#e36209'];
    const SUBSCRIPTS = ['₀','₁','₂','₃','₄','₅','₆','₇','₈','₉'];
    const activeTouches = new Map();

    function toSubscript(number) {
      return String(number)
        .split('')
        .map(digit => SUBSCRIPTS[Number(digit)] || digit)
        .join('');
    }

    function nextFunctionLabel() {
      state.functionCounter += 1;
      return `f${toSubscript(state.functionCounter)}(x)`;
    }

    const KEYBOARD_SETS = [
      {
        id: 'numeric',
        label: '123',
        rows: [
          [
            { text: '7' },
            { text: '8' },
            { text: '9' },
            { text: '/' },
            { text: '^' }
          ],
          [
            { text: '4' },
            { text: '5' },
            { text: '6' },
            { text: '*' },
            { text: '-' }
          ],
          [
            { text: '1' },
            { text: '2' },
            { text: '3' },
            { text: '+' },
            { text: ',' }
          ],
          [
            { text: '0', classes: 'wide' },
            { text: '.', classes: 'small' },
            { text: '(', classes: 'small' },
            { text: ')', classes: 'small' },
            { text: 'x', classes: 'small' },
            { text: 'y', classes: 'small' },
            { text: 'π', insert: 'PI' },
            { text: 'e', insert: 'E' },
            { text: '⌫', action: 'backspace', classes: 'small' }
          ]
        ]
      },
      {
        id: 'functions',
        label: 'f(x)',
        rows: [
          [
            { text: 'sin', insert: 'sin()', cursorOffset: -1 },
            { text: 'cos', insert: 'cos()', cursorOffset: -1 },
            { text: 'tan', insert: 'tan()', cursorOffset: -1 },
            { text: '√', insert: 'sqrt()', cursorOffset: -1 },
            { text: '^2', insert: '^2' }
          ],
          [
            { text: 'asin', insert: 'asin()', cursorOffset: -1 },
            { text: 'acos', insert: 'acos()', cursorOffset: -1 },
            { text: 'atan', insert: 'atan()', cursorOffset: -1 },
            { text: 'ln', insert: 'ln()', cursorOffset: -1 },
            { text: 'log10', insert: 'log10()', cursorOffset: -1 }
          ],
          [
            { text: 'sinh', insert: 'sinh()', cursorOffset: -1 },
            { text: 'cosh', insert: 'cosh()', cursorOffset: -1 },
            { text: 'tanh', insert: 'tanh()', cursorOffset: -1 },
            { text: 'log2', insert: 'log2()', cursorOffset: -1 },
            { text: 'abs', insert: 'abs()', cursorOffset: -1 }
          ],
          [
            { text: '|x|', insert: 'abs()', cursorOffset: -1 },
            { text: 'sgn', insert: 'sign()', cursorOffset: -1 },
            { text: 'floor', insert: 'floor()', cursorOffset: -1 },
            { text: 'ceil', insert: 'ceil()', cursorOffset: -1 },
            { text: '↵', action: 'enter', classes: 'wide' }
          ]
        ]
      },
      {
        id: 'letters',
        label: 'ABC',
        rows: [
          [
            { text: 'a' },
            { text: 'b' },
            { text: 'c' },
            { text: 'd' },
            { text: 'e' },
            { text: 'f' },
            { text: 'g' }
          ],
          [
            { text: 'h' },
            { text: 'i' },
            { text: 'j' },
            { text: 'k' },
            { text: 'l' },
            { text: 'm' },
            { text: 'n' }
          ],
          [
            { text: 'o' },
            { text: 'p' },
            { text: 'q' },
            { text: 'r' },
            { text: 's' },
            { text: 't' },
            { text: 'u' }
          ],
          [
            { text: 'v' },
            { text: 'w' },
            { text: 'x' },
            { text: 'y' },
            { text: 'z' },
            { text: '←', action: 'left', classes: 'small' },
            { text: '→', action: 'right', classes: 'small' },
            { text: '⌫', action: 'backspace', classes: 'small' }
          ]
        ]
      },
      {
        id: 'symbols',
        label: '#&',
        rows: [
          [
            { text: '≤', insert: '<=' },
            { text: '≥', insert: '>=' },
            { text: '≠', insert: '!=' },
            { text: '~' },
            { text: '%' }
          ],
          [
            { text: '∞', insert: 'Infinity' },
            { text: '[', classes: 'small' },
            { text: ']', classes: 'small' },
            { text: '{', classes: 'small' },
            { text: '}', classes: 'small' },
            { text: '|', classes: 'small' }
          ],
          [
            { text: ':', classes: 'small' },
            { text: ';', classes: 'small' },
            { text: '<', classes: 'small' },
            { text: '>', classes: 'small' },
            { text: '=', classes: 'small' },
            { text: '↵', action: 'enter', classes: 'wide' }
          ]
        ]
      }
    ];

    const QUICK_FUNCTION_ACTIONS = [
      { label: 'y = x', value: 'y = x' },
      { label: 'y = x²', value: 'y = x²' },
      { label: 'y = sin(x)', value: 'y = sin(x)' },
      { label: 'y = |x|', value: 'y = |x|' }
    ];

    let keyboardVisible = false;
    let skipNextKeyboardToggleClick = false;
    let activeKeyboardSet = KEYBOARD_SETS[0].id;
    let keyboardBuilt = false;

    function resizeCanvas() {
      const { clientWidth, clientHeight } = canvas;
      canvas.width = clientWidth * DPR;
      canvas.height = clientHeight * DPR;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      draw();
    }

    function worldToScreen({ x, y }) {
      return {
        x: state.origin.x + x * state.scale,
        y: state.origin.y - y * state.scale
      };
    }

    function screenToWorld(x, y) {
      return {
        x: (x - state.origin.x) / state.scale,
        y: (state.origin.y - y) / state.scale
      };
    }

    function clampScale(value) {
      return Math.min(240, Math.max(20, value));
    }

    function getTickStep() {
      const pixelsPerUnit = state.scale;
      if (!Number.isFinite(pixelsPerUnit) || pixelsPerUnit <= 0) {
        return 1;
      }
      const targetPixels = 80;
      const rawStep = targetPixels / pixelsPerUnit;
      const power = Math.pow(10, Math.floor(Math.log10(rawStep)));
      const candidates = [1, 2, 5, 10];
      let step = power;
      for (const candidate of candidates) {
        if (rawStep <= candidate * power) {
          step = candidate * power;
          break;
        }
      }
      if (!Number.isFinite(step) || step <= 0) {
        step = 1;
      }
      return step;
    }

    function getPlotSampleStep() {
      const scale = state.scale;
      if (!Number.isFinite(scale) || scale <= 0) {
        return 1;
      }
      const target = 80 / scale;
      return Math.max(0.25, Math.min(4, target));
    }

    function formatAxisValue(value, step) {
      if (!Number.isFinite(value)) {
        return '';
      }
      const absStep = Math.abs(step) || 1;
      let decimals = 0;
      if (absStep < 1) {
        decimals = Math.ceil(-Math.log10(absStep)) + 2;
      }
      decimals = Math.min(6, Math.max(decimals, absStep < 0.25 ? 3 : 0));
      const factor = Math.pow(10, decimals);
      const normalized = Math.round(value * factor) / factor;
      let text = normalized.toFixed(decimals);
      text = text.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
      if (text === '-0') {
        text = '0';
      }
      return text;
    }

    function drawGrid() {
      const bounds = {
        left: -state.origin.x / state.scale,
        right: (canvas.clientWidth - state.origin.x) / state.scale,
        bottom: -(canvas.clientHeight - state.origin.y) / state.scale,
        top: state.origin.y / state.scale
      };

      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      ctx.lineWidth = 1 / DPR;

      const startX = Math.floor(bounds.left);
      const endX = Math.ceil(bounds.right);
      const startY = Math.floor(bounds.bottom);
      const endY = Math.ceil(bounds.top);

      ctx.strokeStyle = '#e4e8f0';
      ctx.beginPath();
      for (let i = startX; i <= endX; i++) {
        const screenX = Math.round(state.origin.x + i * state.scale) + 0.5;
        ctx.moveTo(screenX, 0);
        ctx.lineTo(screenX, canvas.clientHeight);
      }
      for (let j = startY; j <= endY; j++) {
        const screenY = Math.round(state.origin.y - j * state.scale) + 0.5;
        ctx.moveTo(0, screenY);
        ctx.lineTo(canvas.clientWidth, screenY);
      }
      ctx.stroke();

      const xAxisY = Math.round(state.origin.y) + 0.5;
      const yAxisX = Math.round(state.origin.x) + 0.5;

      ctx.strokeStyle = '#9aa0a6';
      ctx.lineWidth = 1.5 / DPR;
      ctx.beginPath();
      ctx.moveTo(0, xAxisY);
      ctx.lineTo(canvas.clientWidth, xAxisY);
      ctx.moveTo(yAxisX, 0);
      ctx.lineTo(yAxisX, canvas.clientHeight);
      ctx.stroke();

      const tickStep = getTickStep();
      ctx.lineWidth = 1 / DPR;
      ctx.strokeStyle = '#9aa0a6';
      ctx.fillStyle = '#5f6368';
      ctx.font = '12px Inter, "Segoe UI", sans-serif';

      const xAxisVisible = xAxisY >= 0 && xAxisY <= canvas.clientHeight;
      if (xAxisVisible) {
        const xStart = Math.ceil(bounds.left / tickStep) * tickStep;
        ctx.beginPath();
        for (let value = xStart; value <= bounds.right + tickStep * 0.5; value += tickStep) {
          const screenX = Math.round(state.origin.x + value * state.scale) + 0.5;
          ctx.moveTo(screenX, xAxisY - 4);
          ctx.lineTo(screenX, xAxisY + 4);
        }
        ctx.stroke();

        const baseline = xAxisY > canvas.clientHeight - 24 ? 'bottom' : 'top';
        ctx.textAlign = 'center';
        ctx.textBaseline = baseline;
        const offsetY = baseline === 'top' ? 6 : -6;
        for (let value = xStart; value <= bounds.right + tickStep * 0.5; value += tickStep) {
          if (Math.abs(value) < tickStep / 2) continue;
          const screenX = state.origin.x + value * state.scale;
          ctx.fillText(formatAxisValue(value, tickStep), screenX, xAxisY + offsetY);
        }
      }

      const yAxisVisible = yAxisX >= 0 && yAxisX <= canvas.clientWidth;
      if (yAxisVisible) {
        const yStart = Math.ceil(bounds.bottom / tickStep) * tickStep;
        ctx.beginPath();
        for (let value = yStart; value <= bounds.top + tickStep * 0.5; value += tickStep) {
          const screenY = Math.round(state.origin.y - value * state.scale) + 0.5;
          ctx.moveTo(yAxisX - 4, screenY);
          ctx.lineTo(yAxisX + 4, screenY);
        }
        ctx.stroke();

        const align = yAxisX > canvas.clientWidth - 48 ? 'right' : 'left';
        ctx.textAlign = align;
        ctx.textBaseline = 'middle';
        const offsetX = align === 'left' ? 6 : -6;
        for (let value = yStart; value <= bounds.top + tickStep * 0.5; value += tickStep) {
          if (Math.abs(value) < tickStep / 2) continue;
          const screenY = state.origin.y - value * state.scale;
          ctx.fillText(formatAxisValue(value, tickStep), yAxisX + offsetX, screenY);
        }
      }

      if (xAxisVisible && yAxisVisible) {
        const align = yAxisX > canvas.clientWidth - 48 ? 'right' : 'left';
        const baseline = xAxisY > canvas.clientHeight - 24 ? 'bottom' : 'top';
        ctx.textAlign = align;
        ctx.textBaseline = baseline;
        const offsetX = align === 'left' ? 6 : -6;
        const offsetY = baseline === 'top' ? 6 : -6;
        ctx.fillText('0', state.origin.x + offsetX, state.origin.y + offsetY);
      }

      ctx.restore();
    }

    function drawPoints() {
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.fillStyle = COLORS.point;
      for (const point of state.points) {
        const { x, y } = worldToScreen(point.position);
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = COLORS.point;
        ctx.font = '12px Inter, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(point.name, x + 8, y + 6);
      }
      ctx.restore();
    }

    function drawLines() {
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.lineWidth = 2 / DPR;

      for (const line of state.lines) {
        ctx.strokeStyle = COLORS.line;
        const { p1, p2 } = line;
        const a = state.points.find(p => p.id === p1);
        const b = state.points.find(p => p.id === p2);
        if (!a || !b) continue;
        const A = worldToScreen(a.position);
        const B = worldToScreen(b.position);
        const dir = { x: B.x - A.x, y: B.y - A.y };
        const len = Math.hypot(dir.x, dir.y) || 1;
        const unit = { x: dir.x / len, y: dir.y / len };
        const large = 4000;
        ctx.beginPath();
        ctx.moveTo(A.x - unit.x * large, A.y - unit.y * large);
        ctx.lineTo(A.x + unit.x * large, A.y + unit.y * large);
        ctx.stroke();
      }

      for (const segment of state.segments) {
        ctx.strokeStyle = COLORS.segment;
        const { p1, p2 } = segment;
        const a = state.points.find(p => p.id === p1);
        const b = state.points.find(p => p.id === p2);
        if (!a || !b) continue;
        const A = worldToScreen(a.position);
        const B = worldToScreen(b.position);
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }

      for (const polygon of state.polygons) {
        if (polygon.points.length < 3) continue;
        ctx.fillStyle = 'rgba(0,150,136,0.15)';
        ctx.strokeStyle = COLORS.polygon;
        ctx.beginPath();
        const start = state.points.find(p => p.id === polygon.points[0]);
        if (!start) continue;
        const first = worldToScreen(start.position);
        ctx.moveTo(first.x, first.y);
        for (let i = 1; i < polygon.points.length; i++) {
          const pt = state.points.find(p => p.id === polygon.points[i]);
          if (!pt) continue;
          const pos = worldToScreen(pt.position);
          ctx.lineTo(pos.x, pos.y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      for (const circle of state.circles) {
        const center = state.points.find(p => p.id === circle.center);
        const edge = state.points.find(p => p.id === circle.edge);
        if (!center || !edge) continue;
        const C = worldToScreen(center.position);
        const radius = distance(center.position, edge.position) * state.scale;
        ctx.strokeStyle = COLORS.circle;
        ctx.beginPath();
        ctx.arc(C.x, C.y, radius, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawFunctions() {
      if (!state.functions.length) return;
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.lineWidth = 2 / DPR;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const sampleStep = getPlotSampleStep();
      const steps = sampleStep > 0 ? Math.ceil(width / sampleStep) : width;
      const verticalThreshold = height * 4;
      const scale = state.scale;
      if (!Number.isFinite(scale) || scale <= 0) {
        ctx.restore();
        return;
      }
      const originX = state.origin.x;
      const originY = state.origin.y;
      const inverseScale = 1 / scale;
      for (const fn of state.functions) {
        ctx.strokeStyle = fn.color || COLORS.function;
        ctx.beginPath();
        let pathStarted = false;
        let previousPoint = null;
        let fallbackPoint = null;
        let labelPoint = null;
        for (let index = 0; index <= steps; index++) {
          const sx = index === steps ? width : Math.min(index * sampleStep, width);
          const worldX = (sx - originX) * inverseScale;
          let value;
          try {
            value = fn.eval(worldX);
          } catch (err) {
            pathStarted = false;
            previousPoint = null;
            continue;
          }
          if (!Number.isFinite(value) || Math.abs(value) > 1e6) {
            pathStarted = false;
            previousPoint = null;
            continue;
          }
          const sy = originY - value * scale;
          if (!Number.isFinite(sy)) {
            pathStarted = false;
            previousPoint = null;
            continue;
          }
          const largeJump = previousPoint && Math.abs(sy - previousPoint.sy) > verticalThreshold;
          if (!pathStarted || largeJump) {
            ctx.moveTo(sx, sy);
            pathStarted = true;
          } else {
            ctx.lineTo(sx, sy);
          }
          if (!fallbackPoint) {
            fallbackPoint = { x: sx, y: sy };
          }
          if (!labelPoint && sx >= width * 0.25) {
            labelPoint = { x: sx, y: sy };
          }
          previousPoint = { sx, sy };
        }
        ctx.stroke();
        const anchor = labelPoint || fallbackPoint;
        if (anchor) {
          drawFunctionLabel(fn, anchor);
        }
      }
      ctx.restore();
    }

    function drawFunctionLabel(fn, anchor) {
      const text = fn.displayName || fn.algebraLabel || fn.label;
      if (!text) return;
      ctx.save();
      ctx.font = '13px Inter, "Segoe UI", sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const paddingX = 8;
      const boxHeight = 24;
      const metrics = ctx.measureText(text);
      const boxWidth = metrics.width + paddingX * 2;
      let boxX = anchor.x + 12;
      let boxY = anchor.y - boxHeight / 2;
      if (boxX + boxWidth > canvas.clientWidth - 8) {
        boxX = canvas.clientWidth - boxWidth - 8;
      }
      if (boxX < 8) {
        boxX = 8;
      }
      if (boxY < 8) {
        boxY = anchor.y + 12;
      }
      if (boxY + boxHeight > canvas.clientHeight - 8) {
        boxY = canvas.clientHeight - boxHeight - 8;
      }
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 1 / DPR;
      ctx.beginPath();
      ctx.rect(boxX, boxY, boxWidth, boxHeight);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = fn.color || COLORS.function;
      ctx.fillText(text, boxX + paddingX, boxY + boxHeight / 2);
      ctx.restore();
    }

    function drawTexts() {
      if (!state.texts.length) return;
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.fillStyle = COLORS.text;
      ctx.font = '14px Inter, sans-serif';
      for (const label of state.texts) {
        const { x, y } = worldToScreen(label.position);
        ctx.fillText(label.content, x, y);
      }
      ctx.restore();
    }

    function drawPolygonPreview() {
      if (!state.tempPolygon || state.tempPolygon.points.length === 0) return;
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 2 / DPR;
      ctx.strokeStyle = COLORS.polygon;

      const vertices = state.tempPolygon.points
        .map(id => state.points.find(p => p.id === id))
        .filter(Boolean);
      if (vertices.length === 0) {
        ctx.restore();
        return;
      }

      ctx.beginPath();
      const first = worldToScreen(vertices[0].position);
      ctx.moveTo(first.x, first.y);
      for (let i = 1; i < vertices.length; i++) {
        const pos = worldToScreen(vertices[i].position);
        ctx.lineTo(pos.x, pos.y);
      }
      if (state.tempPolygon.preview) {
        const preview = worldToScreen(state.tempPolygon.preview);
        ctx.lineTo(preview.x, preview.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      drawGrid();
      drawLines();
      drawPolygonPreview();
      drawFunctions();
      drawPoints();
      drawTexts();
    }

    function setTool(tool) {
      state.tool = tool;
      document.querySelectorAll('.tool-button[data-tool]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tool === tool);
      });
      state.tempPoints = [];
    }

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function findPointNear(world, threshold = 0.25) {
      let closest = null;
      let min = Infinity;
      for (const point of state.points) {
        const dist = distance(point.position, world);
        if (dist < threshold && dist < min) {
          min = dist;
          closest = point;
        }
      }
      return closest;
    }

    function snapWorldToGrid(world) {
      const position = { x: world.x, y: world.y };
      if (!Number.isFinite(state.scale) || state.scale <= 0) {
        return position;
      }
      const snapped = {
        x: Math.round(position.x),
        y: Math.round(position.y)
      };
      const originalScreen = worldToScreen(position);
      const snappedScreen = worldToScreen(snapped);
      const distancePx = Math.hypot(originalScreen.x - snappedScreen.x, originalScreen.y - snappedScreen.y);
      const thresholdPx = Math.max(6, Math.min(18, state.scale * 0.25));
      if (distancePx <= thresholdPx) {
        return snapped;
      }
      return position;
    }

    let pointCounter = 0;
    function nextPointName() {
      const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let index = pointCounter++;
      let name = '';
      do {
        name = code[index % code.length] + name;
        index = Math.floor(index / code.length) - 1;
      } while (index >= 0);
      return name;
    }

    function createPoint(world, existingName, options = {}) {
      const name = existingName || nextPointName();
      const shouldSnap = options.snap !== false;
      const position = shouldSnap ? snapWorldToGrid(world) : { x: world.x, y: world.y };
      const point = {
        id: crypto.randomUUID(),
        name,
        position
      };
      state.points.push(point);
      registerAlgebraEntry(point.id, `${name} = (${formatNumber(point.position.x)}, ${formatNumber(point.position.y)})`, 'point');
      draw();
      return point;
    }

    function registerAlgebraEntry(id, text, type, color) {
      const [title, ...rest] = text.split('=');
      const strongText = title.trim();
      const detailText = rest.join('=').trim();
      let item = algebraList.querySelector(`[data-id="${id}"]`);
      if (!item) {
        item = document.createElement('div');
        item.className = 'algebra-item';
        item.dataset.id = id;
        item.dataset.type = type;

        const icon = document.createElement('span');
        icon.className = 'algebra-color';
        item.appendChild(icon);

        const label = document.createElement('div');
        label.className = 'algebra-label';
        const strong = document.createElement('strong');
        const span = document.createElement('span');
        span.className = 'algebra-detail';
        label.appendChild(strong);
        label.appendChild(span);
        item.appendChild(label);

        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'delete-button';
        removeButton.setAttribute('aria-label', 'Verwijder object');
        removeButton.innerHTML = `
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <path d="M6 6 18 18" />
            <path d="M6 18 18 6" />
          </svg>
        `;
        item.appendChild(removeButton);

        algebraList.appendChild(item);
      }

      item.dataset.type = type;
      const iconEl = item.querySelector('.algebra-color');
      if (iconEl) {
        iconEl.style.background = color || COLORS[type] || '#888';
      }
      const strongEl = item.querySelector('.algebra-label strong');
      if (strongEl) {
        strongEl.textContent = strongText;
      }
      const detailEl = item.querySelector('.algebra-detail');
      if (detailEl) {
        detailEl.textContent = detailText ? `= ${detailText}` : '';
      }

      algebraList.scrollTo({ top: algebraList.scrollHeight, behavior: 'smooth' });
    }

    function removeAlgebraEntry(id) {
      const item = algebraList.querySelector(`[data-id="${id}"]`);
      if (item) {
        item.remove();
      }
    }

    function buildQuickActions() {
      if (!quickActions) return;
      quickActions.innerHTML = '';
      for (const action of QUICK_FUNCTION_ACTIONS) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'quick-action';
        button.textContent = action.label;
        button.dataset.value = action.value;
        quickActions.appendChild(button);
      }
    }

    function applyQuickAction(value) {
      if (!value) return;
      commandInput.value = value;
      const position = value.length;
      commandInput.setSelectionRange(position, position);
      commandInput.focus();
      if (window.innerWidth < 920 && !keyboardVisible) {
        setKeyboardVisibility(true);
      }
    }

    function ensureKeyboardBuilt() {
      if (keyboardBuilt) return;
      keyboardBuilt = true;
      keyboardTabs.innerHTML = '';
      for (const set of KEYBOARD_SETS) {
        const tab = document.createElement('button');
        tab.type = 'button';
        tab.className = 'keyboard-tab';
        tab.dataset.set = set.id;
        tab.textContent = set.label;
        tab.addEventListener('click', () => setActiveKeyboardSet(set.id));
        keyboardTabs.appendChild(tab);
      }
      setActiveKeyboardSet(activeKeyboardSet);
    }

    function setActiveKeyboardSet(id) {
      activeKeyboardSet = id;
      keyboardTabs.querySelectorAll('.keyboard-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.set === id);
      });
      renderKeyboardRows(id);
    }

    function renderKeyboardRows(id) {
      const set = KEYBOARD_SETS.find(entry => entry.id === id);
      if (!set) return;
      keyboardRows.innerHTML = '';
      for (const row of set.rows) {
        const rowElement = document.createElement('div');
        rowElement.className = 'keyboard-row';
        for (const key of row) {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = `keyboard-key${key.classes ? ` ${key.classes}` : ''}`;
          button.textContent = key.text;
          button.addEventListener('pointerdown', event => {
            event.preventDefault();
            handleKeyboardKey(key);
          });
          button.addEventListener('click', event => event.preventDefault());
          rowElement.appendChild(button);
        }
        keyboardRows.appendChild(rowElement);
      }
    }

    function handleKeyboardKey(key) {
      commandInput.focus();
      if (key.action === 'backspace') {
        deleteAtCursor();
        return;
      }
      if (key.action === 'enter') {
        submitCommandFromKeyboard();
        return;
      }
      if (key.action === 'left') {
        moveCursor(-1);
        return;
      }
      if (key.action === 'right') {
        moveCursor(1);
        return;
      }
      const insertion = key.insert ?? key.text;
      const offset = key.cursorOffset ?? 0;
      insertAtCursor(insertion, offset);
    }

    function insertAtCursor(text, cursorOffset = 0) {
      const start = commandInput.selectionStart ?? commandInput.value.length;
      const end = commandInput.selectionEnd ?? commandInput.value.length;
      const before = commandInput.value.slice(0, start);
      const after = commandInput.value.slice(end);
      commandInput.value = before + text + after;
      const position = start + text.length + cursorOffset;
      commandInput.setSelectionRange(position, position);
    }

    function deleteAtCursor() {
      const start = commandInput.selectionStart ?? commandInput.value.length;
      const end = commandInput.selectionEnd ?? commandInput.value.length;
      if (start !== end) {
        const before = commandInput.value.slice(0, start);
        const after = commandInput.value.slice(end);
        commandInput.value = before + after;
        commandInput.setSelectionRange(start, start);
        return;
      }
      if (start === 0) return;
      const before = commandInput.value.slice(0, start - 1);
      const after = commandInput.value.slice(end);
      commandInput.value = before + after;
      commandInput.setSelectionRange(start - 1, start - 1);
    }

    function moveCursor(delta) {
      const length = commandInput.value.length;
      let position = (commandInput.selectionStart ?? length) + delta;
      position = Math.max(0, Math.min(length, position));
      commandInput.setSelectionRange(position, position);
    }

    function submitCommandFromKeyboard() {
      if (!commandInput.value.trim()) return;
      parseCommand(commandInput.value);
      commandInput.value = '';
    }

    function setKeyboardVisibility(visible) {
      if (visible) {
        ensureKeyboardBuilt();
      }
      keyboardVisible = visible;
      keyboard.classList.toggle('active', visible);
      keyboard.setAttribute('aria-hidden', String(!visible));
      keyboardToggle.classList.toggle('active', visible);
      if (visible) {
        commandInput.focus();
      }
      keyboardToggle.setAttribute('aria-label', visible ? 'Verberg toetsenbord' : 'Toon toetsenbord');
      keyboardToggle.setAttribute('aria-pressed', String(visible));
      requestAnimationFrame(resizeCanvas);
    }

    function prepareExpression(expression) {
      if (!expression) return '';
      const superscripts = {
        '⁰': '^0',
        '¹': '^1',
        '²': '^2',
        '³': '^3',
        '⁴': '^4',
        '⁵': '^5',
        '⁶': '^6',
        '⁷': '^7',
        '⁸': '^8',
        '⁹': '^9'
      };
      let normalized = expression.replace(/[⁰¹²³⁴⁵⁶⁷⁸⁹]/g, char => superscripts[char] || char);
      normalized = normalized
        .replace(/\s+/g, '')
        .replace(/[,;]/g, '.')
        .replace(/√/g, 'sqrt')
        .replace(/π/gi, 'PI')
        .replace(/\bpi\b/gi, 'PI')
        .replace(/τ/gi, '(2*PI)')
        .replace(/\btau\b/gi, '(2*PI)')
        .replace(/[·×]/g, '*')
        .replace(/[–—]/g, '-')
        .replace(/÷/g, '/')
        .replace(/\bsgn\b/gi, 'sign')
        .replace(/\bctg\b/gi, 'cot')
        .replace(/\|([^|]+)\|/g, 'abs($1)');
      const lowerFunctions = ['sin','cos','tan','cot','sec','csc','asin','acos','atan','atan2','sinh','cosh','tanh','asinh','acosh','atanh','log','ln','abs','sqrt','floor','ceil','round','exp','sign','sgn','log10','log2','min','max','pow','hypot'];
      for (const name of lowerFunctions) {
        const regex = new RegExp(name, 'gi');
        normalized = normalized.replace(regex, name);
      }
      const implicitFunctions = [...new Set(lowerFunctions)].sort((a, b) => b.length - a.length);
      for (const name of implicitFunctions) {
        const pattern = new RegExp(`([0-9xy)])(${name})`, 'gi');
        normalized = normalized.replace(pattern, (_match, left, fnName) => `${left}*${fnName}`);
      }
      normalized = normalized
        .replace(/\^/g, '**')
        .replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|sinh|cosh|tanh|asinh|acosh|atanh|ln|log|exp)\*\*([0-9]+)\(([^()]+)\)/g, (_match, fn, power, inner) => `pow(${fn}(${inner}),${power})`)
        .replace(/--/g, '+')
        .replace(/\+\+/g, '+')
        .replace(/\+-/g, '-')
        .replace(/-\+/g, '-')
        .replace(/\be\b/gi, 'E');
      normalized = normalized
        .replace(/([0-9])([xy])/gi, '$1*$2')
        .replace(/([xy])([0-9])/gi, '$1*$2')
        .replace(/([xy])([xy])/gi, '$1*$2')
        .replace(/([xy])\(/gi, '$1*(')
        .replace(/\)([xy])/gi, ')*$1')
        .replace(/([0-9])\(/g, '$1*(')
        .replace(/\)([0-9])/g, ')*$1')
        .replace(/\)\(/g, ')*(');
      normalized = normalized
        .replace(/([0-9xy)])PI/gi, '$1*PI')
        .replace(/PI([A-Za-z0-9(])/g, 'PI*$1')
        .replace(/([0-9xy)])E(?![+-]?\d)/gi, '$1*E')
        .replace(/E([xy(])/gi, 'E*$1');
      if (normalized.includes('|')) {
        throw new Error('Ongebalanceerde absolute waarde.');
      }
      return normalized;
    }

    function registerFunction({ algebraLabel, expression, source, graphLabel, evaluationExpression }) {
      const color = FUNCTION_COLORS[state.functionColorIndex % FUNCTION_COLORS.length];
      try {
        const prepared = prepareExpression(evaluationExpression || expression);
        const compiled = new Function(
          'x',
          `const ln = Math.log;
           const log = Math.log10 ? Math.log10 : (v => Math.log(v) / Math.LN10);
           const log10 = Math.log10 ? Math.log10 : (v => Math.log(v) / Math.LN10);
           const log2 = Math.log2 ? Math.log2 : (v => Math.log(v) / Math.LN2);
           const sign = Math.sign;
           const sgn = Math.sign;
           const abs = Math.abs;
           const sec = x => 1 / Math.cos(x);
           const csc = x => 1 / Math.sin(x);
           const cot = x => 1 / Math.tan(x);
           const sech = x => 1 / Math.cosh(x);
           const csch = x => 1 / Math.sinh(x);
           const coth = x => 1 / Math.tanh(x);
           const tau = Math.PI * 2;
           with (Math) { return ${prepared}; }`
        );
        const fn = {
          id: crypto.randomUUID(),
          label: graphLabel,
          algebraLabel,
          expression,
          source,
          eval: compiled,
          color,
          displayName: `${graphLabel} = ${expression}`
        };
        state.functions.push(fn);
        state.functionColorIndex = (state.functionColorIndex + 1) % FUNCTION_COLORS.length;
        registerAlgebraEntry(fn.id, `${algebraLabel} = ${expression}`, 'function', color);
        draw();
        return fn;
      } catch (error) {
        console.error(error);
        alert('Kon functie niet interpreteren. Controleer de invoer.');
        return null;
      }
    }

    function updatePointAlgebra(point) {
      const item = algebraList.querySelector(`[data-id="${point.id}"]`);
      if (item) {
        const strong = item.querySelector('.algebra-label strong');
        if (strong) {
          strong.textContent = point.name;
        }
        const span = item.querySelector('.algebra-detail');
        if (span) {
          span.textContent = `= (${formatNumber(point.position.x)}, ${formatNumber(point.position.y)})`;
        }
      }
    }

    function formatNumber(value) {
      return Math.round(value * 1000) / 1000;
    }

    function startPinch() {
      if (activeTouches.size < 2) {
        state.pinch = null;
        return;
      }
      const touches = Array.from(activeTouches.values());
      const [first, second] = touches;
      const rect = canvas.getBoundingClientRect();
      const center = {
        x: (first.x + second.x) / 2 - rect.left,
        y: (first.y + second.y) / 2 - rect.top
      };
      state.pinch = {
        initialDistance: Math.hypot(first.x - second.x, first.y - second.y) || 1,
        initialScale: state.scale,
        center
      };
      state.draggingPoint = null;
      state.panning = false;
    }

    function updatePinch() {
      if (!state.pinch || activeTouches.size < 2) {
        return;
      }
      const touches = Array.from(activeTouches.values());
      const [first, second] = touches;
      const rect = canvas.getBoundingClientRect();
      const center = {
        x: (first.x + second.x) / 2 - rect.left,
        y: (first.y + second.y) / 2 - rect.top
      };
      const worldCenter = screenToWorld(center.x, center.y);
      const distance = Math.hypot(first.x - second.x, first.y - second.y) || state.pinch.initialDistance;
      const scaleFactor = distance / state.pinch.initialDistance;
      const nextScale = clampScale(state.pinch.initialScale * scaleFactor);
      state.scale = nextScale;
      const after = worldToScreen(worldCenter);
      state.origin.x += center.x - after.x;
      state.origin.y += center.y - after.y;
      state.pinch.initialDistance = distance;
      state.pinch.initialScale = state.scale;
      state.pinch.center = center;
      draw();
    }

    function removeObject(id, type, options = {}) {
      const { silent = false } = options;
      if (!id || !type) return;

      switch (type) {
        case 'point': {
          const index = state.points.findIndex(point => point.id === id);
          if (index === -1) break;
          state.points.splice(index, 1);
          const relatedSegments = state.segments.filter(segment => segment.p1 === id || segment.p2 === id);
          relatedSegments.forEach(segment => removeObject(segment.id, 'segment', { silent: true }));
          const relatedLines = state.lines.filter(line => line.p1 === id || line.p2 === id);
          relatedLines.forEach(line => removeObject(line.id, 'line', { silent: true }));
          const relatedCircles = state.circles.filter(circle => circle.center === id || circle.edge === id);
          relatedCircles.forEach(circle => removeObject(circle.id, 'circle', { silent: true }));
          const relatedPolygons = state.polygons.filter(polygon => polygon.points.includes(id));
          relatedPolygons.forEach(polygon => removeObject(polygon.id, 'polygon', { silent: true }));
          if (state.draggingPoint && state.draggingPoint.id === id) {
            state.draggingPoint = null;
          }
          state.tempPoints = state.tempPoints.filter(pointId => pointId !== id);
          if (state.tempPolygon) {
            state.tempPolygon.points = state.tempPolygon.points.filter(pointId => pointId !== id);
            if (state.tempPolygon.points.length < 2) {
              state.tempPolygon = null;
            }
          }
          break;
        }
        case 'segment': {
          state.segments = state.segments.filter(segment => segment.id !== id);
          break;
        }
        case 'line': {
          state.lines = state.lines.filter(line => line.id !== id);
          break;
        }
        case 'circle': {
          state.circles = state.circles.filter(circle => circle.id !== id);
          break;
        }
        case 'polygon': {
          state.polygons = state.polygons.filter(polygon => polygon.id !== id);
          break;
        }
        case 'text': {
          state.texts = state.texts.filter(text => text.id !== id);
          break;
        }
        case 'function': {
          state.functions = state.functions.filter(fn => fn.id !== id);
          break;
        }
        default:
          break;
      }

      removeAlgebraEntry(id);
      if (!silent) {
        draw();
      }
    }

    function handlePointerDown(event) {
      if (event.pointerType === 'touch') {
        activeTouches.set(event.pointerId, { x: event.clientX, y: event.clientY });
        if (activeTouches.size === 2) {
          startPinch();
          event.preventDefault();
          return;
        }
        if (!event.isPrimary) {
          event.preventDefault();
          return;
        }
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const world = screenToWorld(x, y);

      if (state.pinch) {
        event.preventDefault();
        return;
      }

      if (state.tool === 'move') {
        const point = findPointNear(world, 0.3);
        if (point) {
          state.draggingPoint = point;
          const screenPos = worldToScreen(point.position);
          state.dragOffset = { x: screenPos.x - x, y: screenPos.y - y };
        } else {
          state.panning = true;
          state.panStart = { x, y };
        }
      } else if (state.tool === 'point') {
        createPoint(world);
      } else if (state.tool === 'line' || state.tool === 'segment' || state.tool === 'circle') {
        handleConstructionTool(world);
      } else if (state.tool === 'polygon') {
        handlePolygonTool(world);
      } else if (state.tool === 'text') {
        handleTextTool(world);
      }

      event.preventDefault();
    }

    function handlePointerMove(event) {
      if (event.pointerType === 'touch') {
        if (activeTouches.has(event.pointerId)) {
          activeTouches.set(event.pointerId, { x: event.clientX, y: event.clientY });
        }
        if (state.pinch && activeTouches.size >= 2) {
          updatePinch();
          event.preventDefault();
          return;
        }
        if (!event.isPrimary) {
          event.preventDefault();
          return;
        }
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const world = screenToWorld(x, y);

      if (state.draggingPoint) {
        const position = screenToWorld(x + state.dragOffset.x, y + state.dragOffset.y);
        state.draggingPoint.position = snapWorldToGrid(position);
        updatePointAlgebra(state.draggingPoint);
        draw();
      } else if (state.panning) {
        const dx = x - state.panStart.x;
        const dy = y - state.panStart.y;
        state.origin.x += dx;
        state.origin.y += dy;
        state.panStart = { x, y };
        draw();
      }

      if (state.tool === 'polygon' && state.tempPolygon) {
        state.tempPolygon.preview = snapWorldToGrid(world);
        draw();
      }
    }

    function handlePointerUp(event) {
      if (event && event.pointerType === 'touch') {
        activeTouches.delete(event.pointerId);
        if (activeTouches.size >= 2) {
          startPinch();
        } else {
          state.pinch = null;
        }
      }
      state.draggingPoint = null;
      state.panning = false;
      if (state.tempPolygon) {
        state.tempPolygon.preview = null;
      }
    }

    function handleConstructionTool(world) {
      const snappedWorld = snapWorldToGrid(world);
      let point = findPointNear(snappedWorld);
      if (!point) {
        point = createPoint(snappedWorld);
      }
      state.tempPoints.push(point.id);

      if (state.tool === 'line' && state.tempPoints.length === 2) {
        const [p1, p2] = state.tempPoints;
        state.lines.push({ id: crypto.randomUUID(), p1, p2 });
        registerAlgebraEntry(state.lines[state.lines.length - 1].id, `l: lijn(${pointName(p1)}, ${pointName(p2)})`, 'line');
        state.tempPoints = [];
        draw();
      }

      if (state.tool === 'segment' && state.tempPoints.length === 2) {
        const [p1, p2] = state.tempPoints;
        state.segments.push({ id: crypto.randomUUID(), p1, p2 });
        registerAlgebraEntry(state.segments[state.segments.length - 1].id, `s: segment(${pointName(p1)}, ${pointName(p2)})`, 'segment');
        state.tempPoints = [];
        draw();
      }

      if (state.tool === 'circle' && state.tempPoints.length === 2) {
        const [center, edge] = state.tempPoints;
        state.circles.push({ id: crypto.randomUUID(), center, edge });
        registerAlgebraEntry(state.circles[state.circles.length - 1].id, `c: cirkel(${pointName(center)}, ${pointName(edge)})`, 'circle');
        state.tempPoints = [];
        draw();
      }
    }

    function handlePolygonTool(world) {
      if (!state.tempPolygon) {
        state.tempPolygon = { points: [], preview: null };
      } else {
        state.tempPolygon.preview = null;
      }
      const snappedWorld = snapWorldToGrid(world);
      let point = findPointNear(snappedWorld);
      if (!point) point = createPoint(snappedWorld);
      state.tempPolygon.points.push(point.id);
      if (state.tempPolygon.points.length > 2 && point.id === state.tempPolygon.points[0]) {
        const uniquePoints = [...new Set(state.tempPolygon.points.slice(0, -1))];
        if (uniquePoints.length >= 3) {
          const polygon = { id: crypto.randomUUID(), points: uniquePoints };
          state.polygons.push(polygon);
          registerAlgebraEntry(polygon.id, `p: veelhoek(${uniquePoints.map(pointName).join(', ')})`, 'polygon');
        }
        state.tempPolygon = null;
        draw();
      }
    }

    function handleTextTool(world) {
      const content = prompt('Tekstinhoud:');
      if (!content) return;
      const label = {
        id: crypto.randomUUID(),
        content,
        position: world
      };
      state.texts.push(label);
      registerAlgebraEntry(label.id, `tekst: "${content}"`, 'text');
      draw();
    }

    function pointName(id) {
      const point = state.points.find(p => p.id === id);
      return point ? point.name : '?';
    }

    function handleWheel(event) {
      event.preventDefault();
      const delta = -event.deltaY;
      const factor = delta > 0 ? 1.1 : 0.9;
      const mouse = screenToWorld(event.offsetX, event.offsetY);
      state.scale = clampScale(state.scale * factor);
      const after = worldToScreen(mouse);
      state.origin.x += event.offsetX - after.x;
      state.origin.y += event.offsetY - after.y;
      draw();
    }

    function zoom(factor) {
      const center = {
        x: canvas.clientWidth / 2,
        y: canvas.clientHeight / 2
      };
      const worldCenter = screenToWorld(center.x, center.y);
      state.scale = clampScale(state.scale * factor);
      const after = worldToScreen(worldCenter);
      state.origin.x += center.x - after.x;
      state.origin.y += center.y - after.y;
      draw();
    }

    function resetView() {
      state.scale = 80;
      state.origin = { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 };
      draw();
    }

    function parseCommand(command) {
      const trimmed = command.trim();
      if (!trimmed) return;

      if (!trimmed.includes('=') && /x/i.test(trimmed)) {
        parseCommand(`y = ${trimmed}`);
        return;
      }

      const pointMatch = trimmed.match(/^([A-Za-z]+)\s*=\s*\(([-+]?\d*\.?\d+),\s*([-+]?\d*\.?\d+)\)$/);
      if (pointMatch) {
        const [, name, x, y] = pointMatch;
        const point = createPoint({ x: parseFloat(x), y: parseFloat(y) }, name, { snap: false });
        updatePointAlgebra(point);
        draw();
        return;
      }

      const equationMatch = trimmed.match(/^([^=]+)=\s*(.+)$/);
      if (equationMatch) {
        const leftRaw = equationMatch[1].trim();
        const rightRaw = equationMatch[2].trim();
        const sanitizedLeft = leftRaw.replace(/\s+/g, '');

        const functionCallMatch = sanitizedLeft.match(/^([a-zA-Z][a-zA-Z0-9_]*)\(([a-zA-Z])\)$/);
        const simpleNameMatch = sanitizedLeft.match(/^([a-zA-Z][a-zA-Z0-9_]*)$/);

        let algebraLabel;
        let graphLabel;
        let evaluationExpression = rightRaw;

        if (sanitizedLeft.toLowerCase() === 'y') {
          const generated = nextFunctionLabel();
          algebraLabel = generated;
          graphLabel = generated;
        } else if (functionCallMatch) {
          const [, name, variable] = functionCallMatch;
          const variablePattern = new RegExp(`\\b${variable}\\b`, 'gi');
          evaluationExpression = rightRaw.replace(variablePattern, 'x');
          algebraLabel = `${name}(${variable})`;
          graphLabel = `${name}(x)`;
        } else if (simpleNameMatch) {
          const name = simpleNameMatch[1];
          algebraLabel = `${name}(x)`;
          graphLabel = `${name}(x)`;
        } else {
          const generated = nextFunctionLabel();
          algebraLabel = generated;
          graphLabel = generated;
        }

        registerFunction({
          algebraLabel,
          expression: rightRaw,
          source: trimmed,
          graphLabel,
          evaluationExpression
        });
        return;
      }

      alert('Deze opdracht wordt nog niet ondersteund.');
    }

    function initTools() {
      document.querySelectorAll('.tool-button[data-tool]').forEach(btn => {
        btn.addEventListener('click', () => setTool(btn.dataset.tool));
      });
    }

    function initSidebar() {
      toggleSidebarBtn.addEventListener('click', () => {
        if (window.innerWidth < 920) {
          const open = !document.body.classList.contains('sidebar-open');
          document.body.classList.toggle('sidebar-open', open);
          sidebar.classList.toggle('hidden', !open);
        } else {
          const collapsed = document.body.classList.toggle('sidebar-collapsed');
          sidebar.classList.toggle('collapsed-desktop', collapsed);
          sidebar.classList.remove('hidden');
          requestAnimationFrame(resizeCanvas);
        }
      });
      closeSidebarBtn.addEventListener('click', () => {
        if (window.innerWidth < 920) {
          document.body.classList.remove('sidebar-open');
          sidebar.classList.add('hidden');
        } else {
          document.body.classList.add('sidebar-collapsed');
          sidebar.classList.add('collapsed-desktop');
          sidebar.classList.remove('hidden');
          requestAnimationFrame(resizeCanvas);
        }
      });
    }

    algebraList.addEventListener('click', event => {
      const button = event.target.closest('.delete-button');
      if (!button) return;
      const item = button.closest('.algebra-item');
      if (!item) return;
      removeObject(item.dataset.id, item.dataset.type);
    });

    if (quickActions) {
      quickActions.addEventListener('click', event => {
        const button = event.target.closest('.quick-action');
        if (!button) return;
        applyQuickAction(button.dataset.value || '');
      });
    }

    canvas.addEventListener('pointerdown', handlePointerDown);
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('pointercancel', handlePointerUp);
    canvas.addEventListener('wheel', handleWheel, { passive: false });

    function handleResponsiveSidebar() {
      if (window.innerWidth < 920) {
        const open = document.body.classList.contains('sidebar-open');
        sidebar.classList.toggle('hidden', !open);
        sidebar.classList.remove('collapsed-desktop');
      } else {
        document.body.classList.remove('sidebar-open');
        const collapsed = document.body.classList.contains('sidebar-collapsed');
        sidebar.classList.toggle('collapsed-desktop', collapsed);
        sidebar.classList.remove('hidden');
      }
    }

    window.addEventListener('resize', () => {
      handleResponsiveSidebar();
      resizeCanvas();
    });

    document.getElementById('zoom-in').addEventListener('click', () => zoom(1.2));
    document.getElementById('zoom-out').addEventListener('click', () => zoom(0.8));
    document.getElementById('reset-view').addEventListener('click', resetView);

    keyboardToggle.addEventListener('pointerdown', event => {
      event.preventDefault();
      keyboardToggle.focus();
      setKeyboardVisibility(!keyboardVisible);
      skipNextKeyboardToggleClick = true;
    });

    keyboardToggle.addEventListener('click', event => {
      event.preventDefault();
      if (skipNextKeyboardToggleClick) {
        skipNextKeyboardToggleClick = false;
        return;
      }
      setKeyboardVisibility(!keyboardVisible);
    });

    keyboardToggle.addEventListener('keydown', event => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        setKeyboardVisibility(!keyboardVisible);
        skipNextKeyboardToggleClick = true;
      }
    });

    commandInput.addEventListener('focus', () => {
      if (window.innerWidth < 920 && !keyboardVisible) {
        setKeyboardVisibility(true);
      }
    });

    document.addEventListener('pointerdown', event => {
      if (!keyboardVisible) return;
      const target = event.target;
      if (keyboard.contains(target)) return;
      if (keyboardToggle.contains(target)) return;
      if (commandBar && commandBar.contains(target)) return;
      setKeyboardVisibility(false);
    });

    window.addEventListener('keydown', event => {
      if (event.key === 'Escape' && keyboardVisible) {
        setKeyboardVisibility(false);
      }
    });

    commandInput.addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        parseCommand(commandInput.value);
        commandInput.value = '';
      } else if (event.key === 'Escape') {
        setKeyboardVisibility(false);
      }
    });

    if ('ResizeObserver' in window) {
      const resizeObserver = new ResizeObserver(() => resizeCanvas());
      resizeObserver.observe(graphContainer);
    }

    initTools();
    initSidebar();
    if (window.innerWidth < 920) {
      sidebar.classList.add('hidden');
    }
    handleResponsiveSidebar();
    buildQuickActions();
    resizeCanvas();
  </script>
</body>
</html>
